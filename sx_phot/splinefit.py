from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import numpy as np
from scipy.interpolate import BSpline, make_lsq_spline


@dataclass
class BandSplineResult:
    """Container for one band spline fit.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.
    """

    band_name: str
    band_min_um: float
    band_max_um: float
    assign_min_um: float
    assign_max_um: float
    degree: int
    n_res_el: float
    spacing_mode: str
    spacing_value: float
    knot_vector_um: np.ndarray
    spline: BSpline
    input_indices: np.ndarray
    fit_mask: np.ndarray
    model_flux_jy: np.ndarray
    dense_wavelength_um: np.ndarray
    dense_model_flux_jy: np.ndarray


def spherex_band_definitions() -> List[Dict[str, float]]:
    """Return SPHEREx band edges and unique assignment edges.

    Bands overlap slightly in wavelength. For unique assignment we split each
    overlap at its midpoint so every wavelength maps to exactly one band.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Returns:
        List of dicts with keys:
            name, band_min_um, band_max_um, assign_min_um, assign_max_um.
    """
    bands = [
        {"name": "band1", "band_min_um": 0.744, "band_max_um": 1.116},
        {"name": "band2", "band_min_um": 1.099, "band_max_um": 1.651},
        {"name": "band3", "band_min_um": 1.636, "band_max_um": 2.421},
        {"name": "band4", "band_min_um": 2.423, "band_max_um": 3.822},
        {"name": "band5", "band_min_um": 3.809, "band_max_um": 4.420},
        {"name": "band6", "band_min_um": 4.412, "band_max_um": 5.002},
    ]

    # Midpoints of overlaps for unique assignment.
    mid12 = 0.5 * (bands[0]["band_max_um"] + bands[1]["band_min_um"])
    mid23 = 0.5 * (bands[1]["band_max_um"] + bands[2]["band_min_um"])
    mid45 = 0.5 * (bands[3]["band_max_um"] + bands[4]["band_min_um"])
    mid56 = 0.5 * (bands[4]["band_max_um"] + bands[5]["band_min_um"])

    # Assignment ranges (non-overlapping).
    bands[0]["assign_min_um"], bands[0]["assign_max_um"] = (
        bands[0]["band_min_um"],
        mid12,
    )
    bands[1]["assign_min_um"], bands[1]["assign_max_um"] = (mid12, mid23)
    bands[2]["assign_min_um"], bands[2]["assign_max_um"] = (
        mid23,
        bands[2]["band_max_um"],
    )
    bands[3]["assign_min_um"], bands[3]["assign_max_um"] = (
        bands[3]["band_min_um"],
        mid45,
    )
    bands[4]["assign_min_um"], bands[4]["assign_max_um"] = (mid45, mid56)
    bands[5]["assign_min_um"], bands[5]["assign_max_um"] = (
        mid56,
        bands[5]["band_max_um"],
    )
    return bands


def _robust_clip_mask(values: np.ndarray, cut: float) -> np.ndarray:
    """Return robust outlier mask using MAD with a fallback.

    This follows the keplersplinev2 logic: estimate sigma from MAD, fall back
    to mean absolute deviation if needed, then apply a cut.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Args:
        values: 1D array of residual-like quantities.
        cut: Threshold in units of robust sigma.

    Returns:
        Boolean mask, True for inliers.
    """
    med = np.median(values)
    absdev = np.abs(values - med)
    sigma = 1.4826 * np.median(absdev)

    if sigma < 1.0e-24:
        sigma = 1.253 * np.mean(absdev)

    if sigma < 1.0e-24:
        return np.isfinite(values)

    return absdev <= cut * sigma


def _compute_spacing(
    wavelength_um: np.ndarray,
    bandwidth_um: np.ndarray,
    n_res_el: float,
    spacing_mode: str,
) -> float:
    """Compute knot spacing from per-channel bandwidth and wavelength.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Args:
        wavelength_um: Wavelengths for points in a band.
        bandwidth_um: Bandwidths (resolution elements) for points in a band.
        n_res_el: Number of resolution elements per knot interval.
        spacing_mode: 'linear' for uniform in wavelength, 'log' for uniform in
            ln(wavelength).

    Returns:
        Spacing in microns (linear) or in ln(microns) (log).
    """
    if spacing_mode not in {"linear", "log"}:
        raise ValueError("spacing_mode must be 'linear' or 'log'.")

    if spacing_mode == "linear":
        dlam = np.nanmedian(bandwidth_um)
        return float(n_res_el * dlam)

    dln = np.nanmedian(bandwidth_um / wavelength_um)
    return float(n_res_el * dln)


def _interior_knots(
    x_min: float,
    x_max: float,
    spacing: float,
    spacing_mode: str,
) -> np.ndarray:
    """Generate interior knot positions between x_min and x_max.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Args:
        x_min: Minimum x for the band fit (microns).
        x_max: Maximum x for the band fit (microns).
        spacing: Spacing in microns (linear) or ln(microns) (log).
        spacing_mode: 'linear' or 'log'.

    Returns:
        1D array of interior knot positions in microns.
    """
    if x_max <= x_min:
        return np.array([], dtype=float)

    if spacing <= 0:
        return np.array([], dtype=float)

    if spacing_mode == "linear":
        start = x_min + spacing
        stop = x_max - spacing
        if stop <= start:
            return np.array([], dtype=float)
        return np.arange(start, stop + 0.5 * spacing, spacing)

    lmin = np.log(x_min)
    lmax = np.log(x_max)
    start = lmin + spacing
    stop = lmax - spacing
    if stop <= start:
        return np.array([], dtype=float)
    lgrid = np.arange(start, stop + 0.5 * spacing, spacing)
    return np.exp(lgrid)


def _subsample_knots_for_dof(
    interior_knots: np.ndarray,
    n_points: int,
    degree: int,
) -> np.ndarray:
    """Subsample interior knots so the LSQ problem is not underdetermined.

    For make_lsq_spline, number of coefficients is:
        n_coeff = len(t) - degree - 1
    where t = [xmin]*(k+1) + interior + [xmax]*(k+1)
    so len(t) = 2*(k+1) + n_int, hence:
        n_coeff = n_int + k + 1
    We require n_points >= n_coeff.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Args:
        interior_knots: Proposed interior knots.
        n_points: Number of data points used for fit.
        degree: Spline degree k.

    Returns:
        Possibly reduced set of interior knots.
    """
    max_n_int = n_points - degree - 1
    if max_n_int <= 0:
        return np.array([], dtype=float)

    if interior_knots.size <= max_n_int:
        return interior_knots

    step = int(np.ceil(interior_knots.size / max_n_int))
    reduced = interior_knots[::step]
    if reduced.size > max_n_int:
        reduced = reduced[:max_n_int]
    return reduced


def fit_band_bspline(
    wavelength_um: np.ndarray,
    bandwidth_um: np.ndarray,
    flux_jy: np.ndarray,
    flux_err_jy: np.ndarray,
    input_mask: np.ndarray,
    band_name: str,
    band_min_um: float,
    band_max_um: float,
    assign_min_um: float,
    assign_max_um: float,
    n_res_el: float = 3.0,
    degree: int = 3,
    spacing_mode: str = "log",
    max_iter: int = 8,
    outlier_cut: float = 4.0,
    clip_on_normalized_residuals: bool = True,
    dense_n: int = 800,
) -> BandSplineResult:
    """Fit a weighted B-spline within one SPHEREx band with iterative
    clipping.

    This routine selects the subset of points assigned to the band
    ([assign_min_um, assign_max_um]) and applies the provided
    input_mask. It computes a knot spacing from the median bandwidth
    (linear or logarithmic in wavelength), builds an LSQ B-spline with
    `make_lsq_spline`, and iteratively rejects outliers based on robust
    residual statistics (optionally normalized by flux errors). The
    final spline is evaluated on the input wavelengths and a dense
    wavelength grid for plotting.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Args:
        wavelength_um: Full-spectrum wavelengths (microns).
        bandwidth_um: Full-spectrum channel bandwidths (microns).
        flux_jy: Full-spectrum fluxes (Jy).
        flux_err_jy: Full-spectrum flux errors (Jy).
        input_mask: Boolean mask of points eligible for fitting (e.g. ~masked
            & finite & err>0). This is applied before any iterative clipping.
        band_name: Name of the band.
        band_min_um: Band minimum wavelength (for metadata).
        band_max_um: Band maximum wavelength (for metadata).
        assign_min_um: Unique assignment minimum wavelength.
        assign_max_um: Unique assignment maximum wavelength.
        n_res_el: Number of resolution elements per knot interval.
        degree: Spline degree.
        spacing_mode: 'log' (uniform in ln lambda) or 'linear'.
        max_iter: Maximum number of clip-refit iterations.
        outlier_cut: Outlier threshold in robust-sigma units.
        clip_on_normalized_residuals: If True, clip on (resid/err); else clip
            on resid in Jy.
        dense_n: Number of samples for dense evaluation grid (per band).

    Returns:
        BandSplineResult containing the spline and model evaluations.
    """
    in_band = (wavelength_um >= assign_min_um) & (wavelength_um <= assign_max_um)
    idx = np.where(in_band)[0]
    if idx.size == 0:
        raise ValueError(f"No points assigned to {band_name}.")

    base = input_mask[idx].copy()
    x = wavelength_um[idx].astype(float)
    y = flux_jy[idx].astype(float)
    yerr = flux_err_jy[idx].astype(float)
    dlam = bandwidth_um[idx].astype(float)

    finite = np.isfinite(x) & np.isfinite(y) & np.isfinite(yerr) & np.isfinite(
        dlam
    )
    pos_err = yerr > 0
    base &= finite & pos_err

    if np.count_nonzero(base) < (degree + 2):
        raise ValueError(
            f"Insufficient points in {band_name} after base masking: "
            f"{np.count_nonzero(base)}."
        )

    order = np.argsort(x)
    x, y, yerr, dlam, base, idx = (
        x[order],
        y[order],
        yerr[order],
        dlam[order],
        base[order],
        idx[order],
    )

    x_min = float(np.min(x[base]))
    x_max = float(np.max(x[base]))
    spacing = _compute_spacing(x[base], dlam[base], n_res_el, spacing_mode)

    good = base.copy()
    spline: Optional[BSpline] = None
    knot_vec: Optional[np.ndarray] = None

    for _ in range(max_iter):
        xg = x[good]
        yg = y[good]
        wg = 1.0 / yerr[good]

        x_min_it = float(np.min(xg))
        x_max_it = float(np.max(xg))
        interior = _interior_knots(x_min_it, x_max_it, spacing, spacing_mode)
        interior = _subsample_knots_for_dof(interior, xg.size, degree)

        t = np.concatenate(
            [
                np.full(degree + 1, x_min_it),
                interior,
                np.full(degree + 1, x_max_it),
            ]
        )

        # If xg contains repeated values, make_lsq_spline can fail.
        # We lightly jitter repeated wavelengths within machine precision.
        if np.any(np.diff(xg) == 0):
            eps = np.finfo(float).eps
            xg = xg + eps * np.arange(xg.size)

        spline = make_lsq_spline(xg, yg, t, degree, w=wg)
        knot_vec = t

        model = spline(x)
        resid = y - model
        clip_vals = resid / yerr if clip_on_normalized_residuals else resid

        clip_mask_local = np.zeros_like(good, dtype=bool)
        clip_mask_local[good] = _robust_clip_mask(clip_vals[good], outlier_cut)

        new_good = good & clip_mask_local
        if np.all(new_good == good):
            break
        if np.count_nonzero(new_good) < (degree + 2):
            break
        good = new_good

    if spline is None or knot_vec is None:
        raise RuntimeError(f"Spline fit failed for {band_name}.")

    model_flux = spline(x)

    if spacing_mode == "log":
        dense_wave = np.exp(np.linspace(np.log(x_min), np.log(x_max), dense_n))
    else:
        dense_wave = np.linspace(x_min, x_max, dense_n)

    dense_model = spline(dense_wave)

    return BandSplineResult(
        band_name=band_name,
        band_min_um=band_min_um,
        band_max_um=band_max_um,
        assign_min_um=assign_min_um,
        assign_max_um=assign_max_um,
        degree=degree,
        n_res_el=n_res_el,
        spacing_mode=spacing_mode,
        spacing_value=spacing,
        knot_vector_um=knot_vec,
        spline=spline,
        input_indices=idx,
        fit_mask=good,
        model_flux_jy=model_flux,
        dense_wavelength_um=dense_wave,
        dense_model_flux_jy=dense_model,
    )


def fit_spherex_spectrum_bspline(
    wavelength_um: np.ndarray,
    bandwidth_um: np.ndarray,
    flux_jy: np.ndarray,
    flux_err_jy: np.ndarray,
    masked: Optional[np.ndarray] = None,
    n_res_el: float = 4.0,
    degree: int = 3,
    spacing_mode: str = "log",
    max_iter: int = 8,
    outlier_cut: float = 3.0,
    clip_on_normalized_residuals: bool = True,
    dense_n_per_band: int = 800,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, Dict[str, BandSplineResult]]:
    """Fit band-wise B-splines to a SPHEREx spectrum and return evaluations.

    Generated by ChatGPT GPT-5.2 Thinking on January 13 2026.

    Args:
        wavelength_um: Wavelengths (microns), one per spectral channel.
        bandwidth_um: Channel bandwidths (microns), one per channel.
        flux_jy: Fluxes (Jy).
        flux_err_jy: Flux errors (Jy).
        masked: Optional boolean mask; True means exclude from fitting.
        n_res_el: Number of resolution elements per knot interval.
        degree: Spline degree.
        spacing_mode: 'log' for uniform in ln(lambda), 'linear' for uniform in
            lambda.
        max_iter: Maximum number of clip-refit iterations per band.
        outlier_cut: Robust sigma cut for clipping.
        clip_on_normalized_residuals: If True, clip on (resid/err).
        dense_n_per_band: Number of samples for dense grid per band.

    Returns:
        model_flux_at_input: Model evaluated at input wavelengths (Jy), same
            order as inputs, NaN where not assigned.
        fit_mask_global: Boolean mask, True for points used in final fits
            (and eligible initially).
        dense_wave_um: Concatenated dense wavelength grid across bands.
        dense_model_flux_jy: Model evaluated on dense grid (Jy).
        band_results: Dict mapping band name to BandSplineResult.
    """
    wavelength_um = np.asarray(wavelength_um, dtype=float)
    bandwidth_um = np.asarray(bandwidth_um, dtype=float)
    flux_jy = np.asarray(flux_jy, dtype=float)
    flux_err_jy = np.asarray(flux_err_jy, dtype=float)

    n = wavelength_um.size
    if not (
        bandwidth_um.size == n and flux_jy.size == n and flux_err_jy.size == n
    ):
        raise ValueError("All input arrays must have the same length.")

    if masked is None:
        masked = np.zeros(n, dtype=bool)
    else:
        masked = np.asarray(masked, dtype=bool)

    eligible = (
        np.isfinite(wavelength_um)
        & np.isfinite(bandwidth_um)
        & np.isfinite(flux_jy)
        & np.isfinite(flux_err_jy)
        & (flux_err_jy > 0)
        & (~masked)
    )

    bands = spherex_band_definitions()
    band_results: Dict[str, BandSplineResult] = {}

    model_flux_at_input = np.full(n, np.nan, dtype=float)
    fit_mask_global = np.zeros(n, dtype=bool)

    dense_waves: List[np.ndarray] = []
    dense_models: List[np.ndarray] = []

    for b in bands:
        res = fit_band_bspline(
            wavelength_um=wavelength_um,
            bandwidth_um=bandwidth_um,
            flux_jy=flux_jy,
            flux_err_jy=flux_err_jy,
            input_mask=eligible,
            band_name=str(b["name"]),
            band_min_um=float(b["band_min_um"]),
            band_max_um=float(b["band_max_um"]),
            assign_min_um=float(b["assign_min_um"]),
            assign_max_um=float(b["assign_max_um"]),
            n_res_el=n_res_el,
            degree=degree,
            spacing_mode=spacing_mode,
            max_iter=max_iter,
            outlier_cut=outlier_cut,
            clip_on_normalized_residuals=clip_on_normalized_residuals,
            dense_n=dense_n_per_band,
        )
        band_results[res.band_name] = res

        # Map back to global arrays.
        model_flux_at_input[res.input_indices] = res.model_flux_jy
        fit_mask_global[res.input_indices] |= res.fit_mask

        dense_waves.append(res.dense_wavelength_um)
        dense_models.append(res.dense_model_flux_jy)

    dense_wave_um = np.concatenate(dense_waves)
    dense_model_flux_jy = np.concatenate(dense_models)

    return (
        model_flux_at_input,
        fit_mask_global,
        dense_wave_um,
        dense_model_flux_jy,
        band_results,
    )
